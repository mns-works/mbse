---
title: 7.16 动作 
slug: 7.16_actions
---

**动作定义和使用**

*动作定义（action definition）*是一种实存定义，用于对动作的表现进行分类。
*动作使用（action usage）*是一种实存使用，是一个或多个动作定义的使用。

TODO:

动作是时间维度上延展的实存，可以和其他动作的表现进行协作，
在参与该表现的项目和部件上产生效果。
TODO:

动作定义和使用遵循结构元素所应用的相同的模式。
动作定义和动作使用可以分解为低层级的动作使用，
产生一个动作树，而动作使用也可以被其他动作所引用。
另外，动作定义可以进行子分类，动作使用可以被子分割或者重定义。
这为修改动作使用的结构树提供了更大的灵活性，可以适应不同的上下文。

**执行动作**

特别地，一个执行动作使用可以作为部件定义或者使用的特征，
表明所引用的动作由所包含的部件在其声明周期内执行。
执行动作也可以是动作定义或者使用的特征。
这种情况下，执行动作使用表示一个从所包含的动作到执行动作的一个“调用”。

**动作顺序**

由于动作使用是实存使用，因此可以使用次序来指定顺序。
然而，动作使用之间的次序，可以额外具有一个*守卫条件（guard condition）*， 
由一个布尔表达式表示。
如果次序具有守卫，那么只有在守卫条件为`true`的时候，次序的源和目标的时间顺序才是确定的。

动作使用的顺序可以进一步被*控制节点（control nodes）*所调整，
这些节点是对动作顺序添加了额外的约束的特殊种类的动作使用。
控制节点总是和其他动作使用通过入向和出向的次序关系连接（守卫是可选的）。
控制节点包括：

  - *分支节点（fork node)* 具有一个进入次序，一个或多个外向次序。
    和出向的次序连接的动作只有在和入向次序连接的动作完成之后才能开始。
  - *集合节点（join node）*
  - *判断节点（decision node)*
  - *合并节点（merge node）*

**动作之间的绑定和流**

动作使用的输出参数可以绑定到另一个动作使用的输入参数上。
这样的绑定表示输入参数的值总是和输出参数的值相同。
如果两个动作并行执行，那么在执行过程中这种等价关系将一直保持。
动作定义或使用的输入参数也可以绑定到内嵌动作使用的输入参数上，
用来将输入参数的值传递给内嵌的动作；
而一个内嵌动作使用的输出参数也可以绑定到所包含的动作定义或使用的输出参数上，
用来讲输出参数的值传递出去。

动作参数之间的绑定并不能对动作之间实际项目的*传输*进行建模，
这种传输需要耗费时间，或者具有其他模型化的属性。
这种传输用流连接来建模更为合适。
串流连接表示在源和目标动作执行过程中，传递可以在流连接中持续发生。
次序流连接则对流连接添加了额外的次序约束，传递在源动作执行完毕之后才能发生，
而目标动作在传递完成之后才能开始。

传递也可以通过*发送和接收动作使用（send and accept action usages）*来执行。
这种情况下，传输的源和目标不需要使用流来显式地连接。
传输的源通过在某个部件或动作中定义的发送动作使用来指定，
而目标由其他部件或动作（可能和源相同）中的接收动作使用来给出。
发送动作使用包括一个表达式，用来产生所传输的值，
并且指定了这些值所发往的目标。
接收动作使用则指定了能够接收的值的类型。
当一个在源中执行的发送动作和在目标中执行的接收动作匹配的时候，
那么值的传递就可以发生。


**赋值动作**

*赋值动作使用（assignment action usage）*用来改变*目标*实存的*引用*特征的值。

### 7.16.6 执行动作 

### 7.16.7 发送和接收动作 

发送动作使用和普通的动作使用类似，之外它还在动作声明和内容体之间
包括一个负载表达式，写在关键字`send`之后；
后面跟着一个发送者表达式，写在关键字`via`之后；
以及一个接收者表达式，写在关键字`to`之后。 
如果声明部分是空的，那么`action`关键字可省略。

```sysml 
    action sendReadingTo {
        in part destination;
        perform getReading { out reading : SensorReading; }
        action sendReading 
            send getReading.reading to destination;
        // 和上一个语句等价，但是没有动作名称
        send getReading.reading to destination;
    }
```