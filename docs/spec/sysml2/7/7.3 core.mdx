## 7.3 Core

### 7.3.1 核心概述
Core层建立在Root层之上，为所要设计、建造以及运行的系统进行建模提供最少需要的构件。
*语义（semantics）*指模型在给定的条件下，如何解释模型以描述事物应该是什么样子（例如，作为所建模系统的一个规范说明）；
或者作为事物的一个反映（例如，作为所建模系统的一个描述）。
KerML语义是基于*分类（classification）*的：模型中的元素是对所建模系统中事物的分类。

*类型（type）*是用来对事物分类的最通用的模型元素。
*分类器（classifier）*是用来对汽车、人或者所执行的程序等事物，根据他们之间如何依据特征来关联进行分类的类型。
*特征（feature）*也属于类型，用来对事物之间的关系进行分类。
除了两个事物之间的简单关系，KerML允许特征来对更长的关系*链（chain）*来进行分类。
例如，居住在特定城市的居民所拥有的汽车，可能需要进行注册。
这些汽车通过一个具有两条关系的链来确定，第一条为汽车的拥有关系，另一个是所有者的居住地关系。

KerML通过使用类型之间的*特化（specialization）*关系来支持分类的分类法表示。
所有被一个特化类型所分类的事物，同时也被通过特化关系关联的更泛化的类型所分类。
这意味着所有被一个特化类型所分类的事物，具有它的所有泛化类型的所有特征，一般叫做从泛化类型到特化类型继承特征。
KerML包括几种特殊类型的特化关系，包括分类器之间的*子分类（subclassification）*关系，特征之间的*子集（subsetting）*和*重定义（redefinition）*关系， 
以及特征和另一个类型之间的*特征类化（feature typing)*关系。

### 7.3.2 类型 
#### 7.3.2.1 类型概述

*类型（Type）*对所建模系统中的事物进行分类。
类型所分类的事物的集合是该类型的*范畴（extent）*，范畴内的每一个成员都是该类型的一个*实例（instance）*。
被建模的每一个事物，都是`Base`模型库中`Anything`类型的一个实例。

类型给定了一个事物属于其范畴之内还是之外的条件（分别为*充分（sufficient）*和*必要（necessary）*条件）。
这些最简单的条件直接确定实例是否必须属于类型的范畴之内。
其他的条件。。。

例如，类型*汽车*可以要求它的范畴之内的所有实例都有四个轮子，意味着任何不具有四个轮子的事物都不在其范畴之内（必要条件）。
然而该条件并不意味着所有四个轮子的事物都在其范畴之内（属于汽车）。
（注意必要条件通常表述为对于范畴之内的所有实例，何种论断为真，尽管实际上他们值决定何种论断非真）。
或者，`汽车`也可以要求所有四个轮子的事物都在其范畴之内（充分条件）。

类型属于命名空间，这使得它们可以通过从属关系来拥有成员。
这些从属关系包括*继承（inherited）*的，来自于它们所拥有的的特化所关联的泛化类型。
继承的从属关系的成员名称必须相互之间，以及和所拥有的从属关系之间可以区分。
引入的从属关系会被继承来的具有相同成员名称的从属关系所隐藏；类似地，它也会被具有同样冲突的拥有的从属关系所隐藏。

**注意**：由于继承产生的名称冲突可以通过将其重定义为一个非冲突的成员名称来解决。

#### 7.3.2.2 类型声明

类型通过关键字`type`声明，后面可以跟一个简称或名称。
另外，类型声明也定义了一个或多个该类型所*拥有的特化（owned specializations)*，
或者一个该类型的*共轭（conjugator）*。 
后面可以再跟一个或多个所*拥有的互斥（owned disjoining)*的定义。

```sysml
    type A specializes Base::Anything disjoint from B;
    type C conjugates A;
```

在关键字`type`之前加上关键字`abstract`可以指定该类型为*抽象（abstract)*的。 
非抽象的类型称为*具象（concrete）*类型。
将一个类型声明为抽象意味着该类型的所有实例必须是该抽象类型的至少一个直接或间接特化的具象类型的实例。

```sysml
abstract type A specializes Base::Anything;
type A1 specializes A;
type A2 specializes A;
```
