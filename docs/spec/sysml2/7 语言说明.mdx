## 7.1 概述

本节对 KerML 提供详细的说明。在第 8 节中，给出了 KerML 元模型的完整定义，作为实现语言的正式规范。
本节中的说明，着重于介绍如何使用不同的语言构件以及内核模型库，来构建模型。
尽管本节的描述是非规范的，但是仍然是精确的，并且和语言的正式规范保持一致。

## 7.2 根

### 7.2.1 根层概述

Root 层提供语言中最通用的语法功能：元素以及他们之间的关系，元素的标记，以及命名空间中元素的成员关系。
在 KerML 中，这些能力是构建模型的语法基础，但是它们并不代表所建模系统的任何东西，
因此不具有语义。
基于 Root 层构建的 Core 层和 Kernel 层提供了具有建模语义的构件。

### 7.2.2 元素和关系

#### 7.2.2.1 概述

*元素 Elements*是模型的构成。某些元素表示元素之间的*关系 relationships*，这些关联的元素称为关系的*相关元素 related elements*。
通俗地说，模型即是一个图（graph），其中关系作为边，连接着作为节点的非关系元素。
然而，由于关系本身也是元素，在 KerML 中，关系也可以作为其他关系的相关元素，也存在关系之间的关系。

一条关系的其中一个相关元素可能是这条关系的*所属 owning*相关元素。
如果关系的所属元素被删除了，那么这个关系也会被删除。
某些相关元素可能是关系的*被拥有的 owned*相关元素。
如果一个关系具有被拥有的相关元素，那么如果该关系被删除，所有它拥有的相关元素也会被删除。

一个元素*拥有的关系owned relationships*是所有把该元素作为所属相关元素的关系。
一个元素*拥有的元素owned elements*是该元素所有拥有的关系上，所有拥有的相关元素。
一个元素的*所属关系 owning relationship*是该元素作为被拥有的相关元素的关系（所属关系最多只能有一个）。
元素的*所有者owner*是该元素的拥有关系的所属相关元素。

> owning relationship 是否具有owner？

关系的删除规则表明，如果一个元素从模型中删除，那么它所拥有的所有关系也被删除，从而它所有拥有的元素也被删除。
这可能导致一系列的删除。
没有所有者的元素作为*所有权树结构 ownership tree structure*的*根元素 root element*，
如果删除它，那么所有的元素和关系都会被删除。
删除其他任意的元素，都会删除以该元素作为根的子树。

#### 7.2.2.2 元素

每一个元素都一个唯一的标识符，作为它的*元素ID*。
在元素的整个生命周期中，它的属性可能会发生变化，但是元素ID在元素创建之后就不会改变。
元素还可能具有额外的标识符，称为*别名ID (alias ID)*。别名ID可能由于工具特定的目的而生成。

KerML的文本符号对于元素ID或别名ID没有任何的规定，因为它们应由建模工具来管理。
元素还可以具有*名称(name)*以及/或者*简称 (short name)*，从而使元素可以在文本符号中被引用。
尽管语言对于名称和简称并没有做正式的区分，元素的名称应该是描述完备的，特别是在元素所定义的上下文里；
而如果提供了简称，那么简称应该是一个缩写，以便于引用该元素。

大多数情况下，元素通过一个表示该元素是哪一*种类(kind)*元素的关键字来*声明(declare)*（例如，**classifier**，或者**feature**）。
元素的声明也可以包括对简称和名称，简称靠前。
简称通过书名号`<` `>`来区分。

```sysml
    classifier <c123> AClassifier;
    feature aFeature;
```

注意，元素的名称和简称并不是必须的。然而，除非至少给定其中一个，在文本表示中是不可能引用该元素的。

名称和简称具有相同的词法结构，有两种变体。

  1. *基本名称 (basic name)* 可以和文本表示的其他部分在词法上区分开来。
    基本名称的初始字符必须是一个小写字母、大写字母或者下划线。
    基本名称的其他字符可以是初始字符所允许的任意字符或者任意数字。
    但是，保留的关键字不能用作名称，即使它具有基本名称所要求的形式。
    ```sysml
    Vehicle
    power_line
    ```
  2. *非受限名称(unrestricted name)*可以用来表示包含任意字符的名称。
    它表示为由单引号所包围的非空字符序列。在单引号*之内*的字符即为名称，而不包括单引号。
    单引号之内的字符不能包括不可打印字符（包括回车，tab以及newline）。
    然而，这些字符可以通过转义序列作为名称的一部分。
    另外，单引号或者反斜杠只能通过转义序列而在名称中使用。
    ```sysml
    '+'
    'circuits in line'
    'On/Off Switch'
    'Ångström'
    ```

除了以上所述的元素声明，元素的表示还可以包括*内容体（body）*，即大括号包裹的该元素的拥有元素的列表。
KerML的文本具象表达式的一个基本原则是拥有元素的表示嵌套在所属元素的内容体中。
这样，当所属元素的标记从模型表示中完全移除时，它拥有的元素也被移除。

```sysml
namespace P {
    // 命名空间P的内容体，声明它所拥有的成员。
    classifier A;
    classifier B {
        // 分类器B的内容体，声明它所拥有的特征。
        feature x;
        feature y;
    }
}
```

#### 7.2.2.3 关系

关系的相关元素被分为*源（source）*和*目标（target）*两种。
关系从源元素*指向（directed）*目标元素。
关系可以只具有源或者目标。
但是，根据约定，*无向（undirected）*关系通常用只具有目标元素的关系来表示。

关系必须至少包括两个相关元素。
具有两个相关元素的关系称为*二元（binary）关系*。
*有向二元关系（directed binary relationship)*是指具有一个源和一个目标的二元关系。
KerML中的大多数关系种类都是有向二元关系（主要的例外包括依赖、关联，以及连接器）。

不同种类的关系通过不同的记号来展示它们的相关元素。
关系也可以具有内容体，用来表示该关系所拥有的相关元素。
如果一个注解元素（注释、文本表示或者元数据特性）被包含在关系的内容体中，
那么该注解元素不是直接作为关系的拥有元素，而是作为该关系所拥有的一个注解关系下的被拥有的元素而存在。

### 7.2.3 依赖

*依赖（dependency）*是在任意数量的客户端（源）和服务端（目标）元素之间一种关系。
它表示服务端的变化，可能导致客户端元素的变化。
依赖可以以一种抽象的方式来表示元素之间的关系。
例如，依赖可以用来表示架构中的顶层可能依赖于底层。

#### 7.2.3.2 依赖声明

依赖通过关键字`dependency`来声明，后面可以添加简称和名称。
依赖的客户端元素在关键字`from`后面，使用逗号分隔的全称列表来表示。
再后面是关键字`to`后面服务端元素的列表。
如果依赖没有指定简称或名称，那么关键字`from`可以省略。

```sysml
    dedependency Use
        from 'Application Layer' to 'Service Layer';
    // 'Service Layer' 是依赖的客户端元素，不是依赖的名称
    dependency 'Service Layer'
        to 'Data Layer', 'External Interface Layer'
```

依赖的声明亦可以具有内容体，包括额外的拥有元素（作为服务端元素），以及通过注解关系被此依赖所拥有的注解元素。

```sysml
    dependency 'Service Layer'
        to 'Data Layer', 'External Interface Layer' {
        /* 'Service Layer' is the client of this dependency,
        * not its name. */
    }
```

### 注解
#### 注解概述

注解





